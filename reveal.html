<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Baby Bomber</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #f0f0f0;
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            position: relative; /* Needed for overlay */
        }

        #gameContainer {
            position: relative;
        }

        #controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 20;
            display: grid;
            grid-template-columns: 50px 50px 50px;
            grid-template-rows: 50px 50px;
            gap: 10px;
        }

        #bombButton {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 80px;
            height: 80px;
            z-index: 20;
        }

        .control-btn {
            background-color: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            color: white;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none; /* Prevent text selection */
        }

        #btn-up { grid-column: 2; grid-row: 1; }
        #btn-left { grid-column: 1; grid-row: 2; }
        #btn-down { grid-column: 2; grid-row: 2; }
        #btn-right { grid-column: 3; grid-row: 2; }

        canvas {
            background-color: #4a5d23; /* Verde oscuro tipo bomberman */
            border: 4px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        h1, #status {
            text-align: center;
            color: #fff;
        }
    </style>
</head>
<body>
    <h1>Baby Bomber</h1>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="controls">
            <div id="btn-up" class="control-btn">â–²</div>
            <div id="btn-left" class="control-btn">â—€</div>
            <div id="btn-down" class="control-btn">â–¼</div>
            <div id="btn-right" class="control-btn">â–¶</div>
        </div>
        <div id="bombButton" class="control-btn">ðŸ’£</div>
    </div>
    <h2 id="status">ðŸŽ¯ Objetivo: Â¡Encuentra la pista escondida!</h2>
    <p>Usa WASD o Flechas para moverte. Presiona [Espacio] para poner una bomba.</p>

    <script>
        // --- 1. CONFIGURACIÃ“N DEL JUEGO ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');

        const TILE_SIZE = 40; // TamaÃ±o de cada celda (pÃ­xeles)
        const ROWS = 13;      // 13 filas
        const COLS = 17;      // 17 columnas

        canvas.width = COLS * TILE_SIZE;
        canvas.height = ROWS * TILE_SIZE;

        // DefiniciÃ³n del mapa
        const MAP_KEY = {
            EMPTY: 0,
            SOLID: 1,
            DESTRUCTIBLE: 2,
            CLUE_HIDDEN: 3,
            CLUE_REVEALED: 4 // The object on the ground
        };

        let map = [];
        let bombs = [];
        let explosions = [];
        let clues = []; // Holds all clue objects {r, c, type, color, revealed}
        let fakeClueMessage = { timer: 0, color: null };
        const TOTAL_FAKE_CLUES = 4;
        let gameWon = false;
        let gameOver = false;

        // --- 2. EL JUGADOR (BEBÃ‰) ---
        let player = {
            x: TILE_SIZE * 1.5,
            y: TILE_SIZE * 1.5,
            initialX: TILE_SIZE * 1.5,
            initialY: TILE_SIZE * 1.5,
            size: TILE_SIZE * 0.6,
            speed: 2,
            color: '#FFDAB9',
            lives: 3,
            invincible: false,
            invincibleTimer: 0
        };

        // --- 3. GENERACIÃ“N DEL MAPA ---
        function generateMap() {
            clues = []; // Reset clues
            let destructibleBlocks = [];
            for (let r = 0; r < ROWS; r++) {
                map[r] = [];
                for (let c = 0; c < COLS; c++) {
                    if (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1 || (r % 2 === 0 && c % 2 === 0)) {
                        map[r][c] = MAP_KEY.SOLID; // Paredes sÃ³lidas
                    } else {
                        // Evitar poner bloques donde empieza el jugador
                        if ((r === 1 && c === 1) || (r === 1 && c === 2) || (r === 2 && c === 1)) {
                             map[r][c] = MAP_KEY.EMPTY;
                        }
                        // Llenar el resto con bloques destruibles
                        else if (Math.random() > 0.1) { // 90% de probabilidad de bloque
                            map[r][c] = MAP_KEY.DESTRUCTIBLE;
                            destructibleBlocks.push({r, c});
                        } else {
                            map[r][c] = MAP_KEY.EMPTY;
                        }
                    }
                }
            }
            
            // --- Place Clues ---
            // Shuffle destructible blocks for random placement
            for (let i = destructibleBlocks.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [destructibleBlocks[i], destructibleBlocks[j]] = [destructibleBlocks[j], destructibleBlocks[i]];
            }

            // Place the real clue
            if (destructibleBlocks.length > 0) {
                const pos = destructibleBlocks.pop();
                map[pos.r][pos.c] = MAP_KEY.CLUE_HIDDEN;
                clues.push({ r: pos.r, c: pos.c, type: 'real', color: '#ADD8E6', revealed: false }); // Light Blue
            }

            // Place fake clues
            const fakeColors = ['#FFC0CB', '#FFB6C1', '#F08080', '#FA8072']; // Pinks/Reds
            for (let i = 0; i < TOTAL_FAKE_CLUES && destructibleBlocks.length > 0; i++) {
                const pos = destructibleBlocks.pop();
                map[pos.r][pos.c] = MAP_KEY.CLUE_HIDDEN;
                clues.push({ r: pos.r, c: pos.c, type: 'fake', color: fakeColors[i % fakeColors.length], revealed: false });
            }
        }

        // --- 4. CONTROLES ---
        let keys = {};
        document.addEventListener('keydown', e => keys[e.code] = true);
        document.addEventListener('keyup', e => keys[e.code] = false);

        document.addEventListener('keydown', e => {
            if (e.code === 'Space' && !gameWon && !gameOver) {
                placeBomb();
            }
        });

        // --- Mobile Controls ---
        function setupMobileControls() {
            const keyMap = {
                'btn-up': 'KeyW',
                'btn-down': 'KeyS',
                'btn-left': 'KeyA',
                'btn-right': 'KeyD'
            };

            for (const btnId in keyMap) {
                const btn = document.getElementById(btnId);
                const key = keyMap[btnId];
                btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; }, { passive: false });
                btn.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; }, { passive: false });
                btn.addEventListener('mousedown', (e) => { e.preventDefault(); keys[key] = true; });
                btn.addEventListener('mouseup', (e) => { e.preventDefault(); keys[key] = false; });
                btn.addEventListener('mouseleave', (e) => { keys[key] = false; }); // Stop moving if finger slides off
            }

            const bombBtn = document.getElementById('bombButton');
            bombBtn.addEventListener('touchstart', (e) => { e.preventDefault(); placeBomb(); }, { passive: false });
            bombBtn.addEventListener('mousedown', (e) => { e.preventDefault(); placeBomb(); });
        }

        // --- 5. LÃ“GICA DEL JUEGO (UPDATE) ---
        function update() {
            if (gameWon || gameOver) return;

            // If a fake clue message is active, only update its timer and pause everything else.
            if (fakeClueMessage.timer > 0) {
                fakeClueMessage.timer--;
                return;
            }

            movePlayer();
            updateBombs();
            updateExplosions();
            updatePlayer();
            checkCluePickup();
        }

        function checkCluePickup() {
            const playerCol = Math.floor(player.x / TILE_SIZE);
            const playerRow = Math.floor(player.y / TILE_SIZE);

            if (map[playerRow][playerCol] !== MAP_KEY.CLUE_REVEALED) return;

            const pickedClueIndex = clues.findIndex(c => c.revealed && c.r === playerRow && c.c === playerCol);
            if (pickedClueIndex === -1) return;

            const pickedClue = clues[pickedClueIndex];

            if (pickedClue.type === 'real') {
                gameWon = true;
            } else {
                // It's a fake clue
                fakeClueMessage.timer = 1000; //180  3 seconds
                fakeClueMessage.color = pickedClue.color;
                map[playerRow][playerCol] = MAP_KEY.EMPTY; // Remove from map
                clues.splice(pickedClueIndex, 1); // Remove from clues array
            }
        }

        function updatePlayer() {
            if (player.invincible) {
                player.invincibleTimer--;
                if (player.invincibleTimer <= 0) {
                    player.invincible = false;
                    player.color = '#FFDAB9'; // Restore original color
                } else {
                    // Blink effect
                    player.color = (player.invincibleTimer % 20 < 10) ? 'white' : '#FFDAB9';
                }
            }
        }

        function movePlayer() {
            let dx = 0;
            let dy = 0;

            if (keys['KeyW'] || keys['ArrowUp']) dy = -player.speed;
            if (keys['KeyS'] || keys['ArrowDown']) dy = player.speed;
            if (keys['KeyA'] || keys['ArrowLeft']) dx = -player.speed;
            if (keys['KeyD'] || keys['ArrowRight']) dx = player.speed;

            // DetecciÃ³n de colisiones simple
            // Revisa la prÃ³xima posiciÃ³n X
            if (dx !== 0 && !isSolid(player.x + dx, player.y)) {
                player.x += dx;
            }
            // Revisa la prÃ³xima posiciÃ³n Y
            if (dy !== 0 && !isSolid(player.x, player.y + dy)) {
                player.y += dy;
            }
        }
        
        function getTileAt(x, y) {
            const r = Math.floor(y / TILE_SIZE);
            const c = Math.floor(x / TILE_SIZE);
            if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return MAP_KEY.SOLID;
            return map[r][c];
        }

        function isSolid(x, y) {
            // Revisa las 4 esquinas del "bebÃ©"
            const radius = player.size / 2;
            const tile1 = getTileAt(x - radius, y - radius); // Arriba-Izquierda
            const tile2 = getTileAt(x + radius, y - radius); // Arriba-Derecha
            const tile3 = getTileAt(x - radius, y + radius); // Abajo-Izquierda
            const tile4 = getTileAt(x + radius, y + radius); // Abajo-Derecha
            
            const solidTypes = [MAP_KEY.SOLID, MAP_KEY.DESTRUCTIBLE, MAP_KEY.CLUE_HIDDEN];
            
            return solidTypes.includes(tile1) || solidTypes.includes(tile2) || solidTypes.includes(tile3) || solidTypes.includes(tile4);
        }

        function placeBomb() {
            // Centrar la bomba en la celda actual
            const r = Math.floor(player.y / TILE_SIZE);
            const c = Math.floor(player.x / TILE_SIZE);

            // Evitar poner dos bombas en la misma celda
            if (bombs.some(b => b.r === r && b.c === c)) return;

            bombs.push({
                r: r,
                c: c,
                timer: 180, // 180 frames (aprox 3 segundos)
                range: 2     // Rango de la explosiÃ³n
            });
        }

        function updateBombs() {
            for (let i = bombs.length - 1; i >= 0; i--) {
                bombs[i].timer--;
                if (bombs[i].timer <= 0) {
                    explode(bombs[i]);
                    bombs.splice(i, 1);
                }
            }
        }
        
        function explode(bomb) {
            const dirs = [[0, 0], [0, 1], [0, -1], [1, 0], [-1, 0]]; // Centro, Abajo, Arriba, Derecha, Izquierda
            
            for (const dir of dirs) {
                for (let i = 0; i <= bomb.range; i++) {
                    const r = bomb.r + dir[0] * i;
                    const c = bomb.c + dir[1] * i;

                    if (r < 0 || r >= ROWS || c < 0 || c >= COLS) break;

                    const tile = map[r][c];
                    
                    // AÃ±adir efecto de explosiÃ³n
                    explosions.push({ r, c, timer: 30 }); // Dura 30 frames

                    if (tile === MAP_KEY.SOLID) {
                        break; // La explosiÃ³n se detiene en pared sÃ³lida
                    }
                    
                    if (tile === MAP_KEY.DESTRUCTIBLE || tile === MAP_KEY.CLUE_HIDDEN) {
                        // Check if a clue is hidden here
                        const clue = clues.find(clue => clue.r === r && clue.c === c);
                        if (clue) {
                            clue.revealed = true;
                            map[r][c] = MAP_KEY.CLUE_REVEALED; // Reveal the clue object
                            statusEl.textContent = "Â¡Encontraste algo! Â¡Ve a recogerlo!";
                        } else {
                            map[r][c] = MAP_KEY.EMPTY; // Just destroy the block
                        }
                        break; // The explosion stops after destroying a block or revealing a clue
                    }
                }
            }
        }
        
        function updateExplosions() {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const exp = explosions[i];
                exp.timer--;

                // Comprobar colisiÃ³n con el jugador
                const playerCol = Math.floor(player.x / TILE_SIZE);
                const playerRow = Math.floor(player.y / TILE_SIZE);
                if (exp.r === playerRow && exp.c === playerCol && !player.invincible) {
                    playerHit();
                }

                if (exp.timer <= 0) {
                    explosions.splice(i, 1);
                }
            }
        }

        function playerHit() {
            if (player.invincible) return;

            player.lives--;
            if (player.lives <= 0) {
                gameOver = true;
                statusEl.textContent = "GAME OVER. Presiona ESPACIO para reiniciar.";
                document.addEventListener('keydown', restartGameOnSpace, { once: true });
            } else {
                // Respawn y dar invencibilidad temporal
                player.x = player.initialX;
                player.y = player.initialY;
                player.invincible = true;
                player.invincibleTimer = 120; // 2 segundos de invencibilidad
            }
        }

        function restartGameOnSpace(e) {
            if (e.code === 'Space') {
                restartGame();
            } else {
                // Si se presiona otra tecla, volver a escuchar
                document.addEventListener('keydown', restartGameOnSpace, { once: true });
            }
        }

        function restartGame() {
            player.lives = 3;
            player.x = player.initialX;
            player.y = player.initialY;
            player.invincible = false;
            player.invincibleTimer = 0;
            
            bombs = [];
            explosions = [];
            clues = []; // This will be repopulated by generateMap
            fakeClueMessage = { timer: 0, color: null };
            gameWon = false;
            gameOver = false;
            
            statusEl.textContent = "ðŸŽ¯ Objetivo: Â¡Encuentra la pista escondida!";
            generateMap();
        }

        // --- 6. RENDERIZADO (DRAW) ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameWon) {
                drawWinScreen();
            } else if (fakeClueMessage.timer > 0) {
                drawFakeClueScreen();
            } else {
                drawMap();
                drawBombs();
                drawExplosions();
                drawPlayer();
                drawUI();
            }
        }

        function drawFakeClueScreen() {
            // Draw a full-screen rectangle with the clue's color
            ctx.fillStyle = fakeClueMessage.color;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw the text
            ctx.fillStyle = 'white';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("Pista falsa, siga jugando", canvas.width / 2, canvas.height / 2);
        }

        function drawWinScreen() {
            // A big light blue square
            ctx.fillStyle = 'lightblue';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Text
            ctx.fillStyle = 'white';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("Â¡ES UN NIÃ‘O!", canvas.width / 2, canvas.height / 2);
            
            statusEl.textContent = "ðŸŽ‰ Â¡FELICIDADES! ðŸŽ‰";
        }

        function drawUI() {
            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(`Vidas: ${player.lives}`, 10, 10);
        }

        function drawMap() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const x = c * TILE_SIZE;
                    const y = r * TILE_SIZE;
                    
                    switch(map[r][c]) {
                        case MAP_KEY.SOLID:
                            ctx.fillStyle = '#555'; // Gris oscuro
                            ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                            break;
                        case MAP_KEY.DESTRUCTIBLE:
                        case MAP_KEY.CLUE_HIDDEN: // Se ve igual que un bloque normal
                            ctx.fillStyle = '#8B4513'; // MarrÃ³n (ladrillo)
                            ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                            break;
                        case MAP_KEY.CLUE_REVEALED:
                            const clue = clues.find(clue => clue.r === r && clue.c === c);
                            if (clue) {
                                ctx.fillStyle = clue.color;
                                ctx.beginPath();
                                ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE / 2, TILE_SIZE / 4, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            break;
                        case MAP_KEY.EMPTY:
                            // Ya estÃ¡ limpio por el fondo del canvas
                            break;
                    }
                }
            }
        }
        
        function drawPlayer() {
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.size / 2, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawBombs() {
            for (const bomb of bombs) {
                const x = bomb.c * TILE_SIZE + TILE_SIZE / 2;
                const y = bomb.r * TILE_SIZE + TILE_SIZE / 2;
                
                // Efecto de parpadeo
                const scale = (bomb.timer % 10 < 5) ? 0.7 : 0.8;
                
                ctx.fillStyle = '#222'; // Bomba negra
                ctx.beginPath();
                ctx.arc(x, y, (TILE_SIZE / 2) * scale, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'white'; // Mecha
                ctx.fillRect(x - 2, y - (TILE_SIZE / 2) * scale - 5, 4, 5);
            }
        }
        
        function drawExplosions() {
            for (const exp of explosions) {
                const x = exp.c * TILE_SIZE;
                const y = exp.r * TILE_SIZE;
                
                // La opacidad disminuye con el tiempo
                ctx.fillStyle = `rgba(255, 165, 0, ${exp.timer / 15})`; 
                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
            }
        }

        // --- 7. BUCLE PRINCIPAL DEL JUEGO ---
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Iniciar el juego
        generateMap();
        setupMobileControls();
        gameLoop();
    </script>
</body>
</html>
