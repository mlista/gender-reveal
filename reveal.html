<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Baby Bomber</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #f0f0f0;
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
        }
        canvas {
            background-color: #4a5d23; /* Verde oscuro tipo bomberman */
            border: 4px solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        h1, #status {
            text-align: center;
            color: #fff;
        }
    </style>
</head>
<body>
    <h1>Baby Bomber</h1>
    <canvas id="gameCanvas"></canvas>
    <h2 id="status"> Objetivo: 隆Encuentra la pista escondida!</h2>
    <p>Usa WASD o Flechas para moverte. Presiona [Espacio] para poner una bomba.</p>

    <script>
        // --- 1. CONFIGURACIN DEL JUEGO ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');

        const TILE_SIZE = 40; // Tama帽o de cada celda (p铆xeles)
        const ROWS = 13;      // 13 filas
        const COLS = 17;      // 17 columnas

        canvas.width = COLS * TILE_SIZE;
        canvas.height = ROWS * TILE_SIZE;

        // Definici贸n del mapa
        const MAP_KEY = {
            EMPTY: 0,
            SOLID: 1,
            DESTRUCTIBLE: 2,
            CLUE_HIDDEN: 3,
            CLUE_REVEALED: 4 // The object on the ground
        };

        let map = [];
        let bombs = [];
        let explosions = [];
        let clueRevealed = null;
        let gameWon = false;
        let gameOver = false;

        // --- 2. EL JUGADOR (BEB) ---
        let player = {
            x: TILE_SIZE * 1.5,
            y: TILE_SIZE * 1.5,
            initialX: TILE_SIZE * 1.5,
            initialY: TILE_SIZE * 1.5,
            size: TILE_SIZE * 0.6,
            speed: 2,
            color: '#FFDAB9',
            lives: 3,
            invincible: false,
            invincibleTimer: 0
        };

        // --- 3. GENERACIN DEL MAPA ---
        function generateMap() {
            let destructibleBlocks = [];
            for (let r = 0; r < ROWS; r++) {
                map[r] = [];
                for (let c = 0; c < COLS; c++) {
                    if (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1 || (r % 2 === 0 && c % 2 === 0)) {
                        map[r][c] = MAP_KEY.SOLID; // Paredes s贸lidas
                    } else {
                        // Evitar poner bloques donde empieza el jugador
                        if ((r === 1 && c === 1) || (r === 1 && c === 2) || (r === 2 && c === 1)) {
                             map[r][c] = MAP_KEY.EMPTY;
                        }
                        // Llenar el resto con bloques destruibles
                        else if (Math.random() > 0.1) { // 90% de probabilidad de bloque
                            map[r][c] = MAP_KEY.DESTRUCTIBLE;
                            destructibleBlocks.push({r, c});
                        } else {
                            map[r][c] = MAP_KEY.EMPTY;
                        }
                    }
                }
            }
            
            // Esconder la pista en un bloque al azar
            if (destructibleBlocks.length > 0) {
                let cluePos = destructibleBlocks[Math.floor(Math.random() * destructibleBlocks.length)];
                map[cluePos.r][cluePos.c] = MAP_KEY.CLUE_HIDDEN;
            }
        }

        // --- 4. CONTROLES ---
        let keys = {};
        document.addEventListener('keydown', e => keys[e.code] = true);
        document.addEventListener('keyup', e => keys[e.code] = false);

        document.addEventListener('keydown', e => {
            if (e.code === 'Space' && !gameWon && !gameOver) {
                placeBomb();
            }
        });

        // --- 5. LGICA DEL JUEGO (UPDATE) ---
        function update() {
            if (gameWon || gameOver) return;
            movePlayer();
            updateBombs();
            updateExplosions();
            updatePlayer();
            checkCluePickup();
        }

        function checkCluePickup() {
            if (!clueRevealed) return;

            const playerCol = Math.floor(player.x / TILE_SIZE);
            const playerRow = Math.floor(player.y / TILE_SIZE);

            if (playerRow === clueRevealed.r && playerCol === clueRevealed.c) {
                gameWon = true;
            }
        }

        function updatePlayer() {
            if (player.invincible) {
                player.invincibleTimer--;
                if (player.invincibleTimer <= 0) {
                    player.invincible = false;
                    player.color = '#FFDAB9'; // Restore original color
                } else {
                    // Blink effect
                    player.color = (player.invincibleTimer % 20 < 10) ? 'white' : '#FFDAB9';
                }
            }
        }

        function movePlayer() {
            let dx = 0;
            let dy = 0;

            if (keys['KeyW'] || keys['ArrowUp']) dy = -player.speed;
            if (keys['KeyS'] || keys['ArrowDown']) dy = player.speed;
            if (keys['KeyA'] || keys['ArrowLeft']) dx = -player.speed;
            if (keys['KeyD'] || keys['ArrowRight']) dx = player.speed;

            // Detecci贸n de colisiones simple
            // Revisa la pr贸xima posici贸n X
            if (dx !== 0 && !isSolid(player.x + dx, player.y)) {
                player.x += dx;
            }
            // Revisa la pr贸xima posici贸n Y
            if (dy !== 0 && !isSolid(player.x, player.y + dy)) {
                player.y += dy;
            }
        }
        
        function getTileAt(x, y) {
            const r = Math.floor(y / TILE_SIZE);
            const c = Math.floor(x / TILE_SIZE);
            if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return MAP_KEY.SOLID;
            return map[r][c];
        }

        function isSolid(x, y) {
            // Revisa las 4 esquinas del "beb茅"
            const radius = player.size / 2;
            const tile1 = getTileAt(x - radius, y - radius); // Arriba-Izquierda
            const tile2 = getTileAt(x + radius, y - radius); // Arriba-Derecha
            const tile3 = getTileAt(x - radius, y + radius); // Abajo-Izquierda
            const tile4 = getTileAt(x + radius, y + radius); // Abajo-Derecha
            
            const solidTypes = [MAP_KEY.SOLID, MAP_KEY.DESTRUCTIBLE, MAP_KEY.CLUE_HIDDEN];
            
            return solidTypes.includes(tile1) || solidTypes.includes(tile2) || solidTypes.includes(tile3) || solidTypes.includes(tile4);
        }

        function placeBomb() {
            // Centrar la bomba en la celda actual
            const r = Math.floor(player.y / TILE_SIZE);
            const c = Math.floor(player.x / TILE_SIZE);

            // Evitar poner dos bombas en la misma celda
            if (bombs.some(b => b.r === r && b.c === c)) return;

            bombs.push({
                r: r,
                c: c,
                timer: 180, // 180 frames (aprox 3 segundos)
                range: 2     // Rango de la explosi贸n
            });
        }

        function updateBombs() {
            for (let i = bombs.length - 1; i >= 0; i--) {
                bombs[i].timer--;
                if (bombs[i].timer <= 0) {
                    explode(bombs[i]);
                    bombs.splice(i, 1);
                }
            }
        }
        
        function explode(bomb) {
            const dirs = [[0, 0], [0, 1], [0, -1], [1, 0], [-1, 0]]; // Centro, Abajo, Arriba, Derecha, Izquierda
            
            for (const dir of dirs) {
                for (let i = 0; i <= bomb.range; i++) {
                    const r = bomb.r + dir[0] * i;
                    const c = bomb.c + dir[1] * i;

                    if (r < 0 || r >= ROWS || c < 0 || c >= COLS) break;

                    const tile = map[r][c];
                    
                    // A帽adir efecto de explosi贸n
                    explosions.push({ r, c, timer: 15 }); // Dura 15 frames

                    if (tile === MAP_KEY.SOLID) {
                        break; // La explosi贸n se detiene en pared s贸lida
                    }
                    
                    if (tile === MAP_KEY.DESTRUCTIBLE) {
                        map[r][c] = MAP_KEY.EMPTY; // Destruye el bloque
                        break; // La explosi贸n se detiene al romper un bloque
                    }
                    
                    if (tile === MAP_KEY.CLUE_HIDDEN) {
                        map[r][c] = MAP_KEY.CLUE_REVEALED; // Reveal the object
                        clueRevealed = { r, c };
                        statusEl.textContent = "隆Encontraste algo! 隆Ve a recogerlo!";
                        break; // Stop explosion spreading through it
                    }
                }
            }
        }
        
        function updateExplosions() {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const exp = explosions[i];
                exp.timer--;

                // Comprobar colisi贸n con el jugador
                const playerCol = Math.floor(player.x / TILE_SIZE);
                const playerRow = Math.floor(player.y / TILE_SIZE);
                if (exp.r === playerRow && exp.c === playerCol && !player.invincible) {
                    playerHit();
                }

                if (exp.timer <= 0) {
                    explosions.splice(i, 1);
                }
            }
        }

        function playerHit() {
            if (player.invincible) return;

            player.lives--;
            if (player.lives <= 0) {
                gameOver = true;
                statusEl.textContent = "GAME OVER. Presiona ESPACIO para reiniciar.";
                document.addEventListener('keydown', restartGameOnSpace, { once: true });
            } else {
                // Respawn y dar invencibilidad temporal
                player.x = player.initialX;
                player.y = player.initialY;
                player.invincible = true;
                player.invincibleTimer = 120; // 2 segundos de invencibilidad
            }
        }

        function restartGameOnSpace(e) {
            if (e.code === 'Space') {
                restartGame();
            } else {
                // Si se presiona otra tecla, volver a escuchar
                document.addEventListener('keydown', restartGameOnSpace, { once: true });
            }
        }

        function restartGame() {
            player.lives = 3;
            player.x = player.initialX;
            player.y = player.initialY;
            player.invincible = false;
            player.invincibleTimer = 0;
            
            bombs = [];
            explosions = [];
            clueRevealed = null;
            gameWon = false;
            gameOver = false;
            
            statusEl.textContent = " Objetivo: 隆Encuentra la pista escondida!";
            generateMap();
        }

        // --- 6. RENDERIZADO (DRAW) ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameWon) {
                drawWinScreen();
            } else {
                drawMap();
                drawBombs();
                drawExplosions();
                drawPlayer();
                drawUI();
            }
        }

        function drawWinScreen() {
            // A big light blue square
            ctx.fillStyle = 'lightblue';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Text
            ctx.fillStyle = 'white';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("隆ES UN NIO!", canvas.width / 2, canvas.height / 2);
            
            statusEl.textContent = " 隆FELICIDADES! ";
        }

        function drawUI() {
            ctx.fillStyle = 'white';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(`Vidas: ${player.lives}`, 10, 10);
        }

        function drawMap() {
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const x = c * TILE_SIZE;
                    const y = r * TILE_SIZE;
                    
                    switch(map[r][c]) {
                        case MAP_KEY.SOLID:
                            ctx.fillStyle = '#555'; // Gris oscuro
                            ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                            break;
                        case MAP_KEY.DESTRUCTIBLE:
                        case MAP_KEY.CLUE_HIDDEN: // Se ve igual que un bloque normal
                            ctx.fillStyle = '#8B4513'; // Marr贸n (ladrillo)
                            ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                            break;
                        case MAP_KEY.CLUE_REVEALED:
                            // Draw a small, intriguing object
                            ctx.fillStyle = '#FFE81C'; // Yellow
                            ctx.beginPath();
                            ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE / 2, TILE_SIZE / 4, 0, Math.PI * 2);
                            ctx.fill();
                            break;
                        case MAP_KEY.EMPTY:
                            // Ya est谩 limpio por el fondo del canvas
                            break;
                    }
                }
            }
        }
        
        function drawPlayer() {
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.size / 2, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawBombs() {
            for (const bomb of bombs) {
                const x = bomb.c * TILE_SIZE + TILE_SIZE / 2;
                const y = bomb.r * TILE_SIZE + TILE_SIZE / 2;
                
                // Efecto de parpadeo
                const scale = (bomb.timer % 10 < 5) ? 0.7 : 0.8;
                
                ctx.fillStyle = '#222'; // Bomba negra
                ctx.beginPath();
                ctx.arc(x, y, (TILE_SIZE / 2) * scale, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'white'; // Mecha
                ctx.fillRect(x - 2, y - (TILE_SIZE / 2) * scale - 5, 4, 5);
            }
        }
        
        function drawExplosions() {
            for (const exp of explosions) {
                const x = exp.c * TILE_SIZE;
                const y = exp.r * TILE_SIZE;
                
                // La opacidad disminuye con el tiempo
                ctx.fillStyle = `rgba(255, 165, 0, ${exp.timer / 15})`; 
                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
            }
        }

        // --- 7. BUCLE PRINCIPAL DEL JUEGO ---
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Iniciar el juego
        generateMap();
        gameLoop();
    </script>
</body>
</html>
