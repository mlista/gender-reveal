<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Baby Bomber</title>
    <style>
        * {
            box-sizing: border-box;
            touch-action: manipulation; /* Prevenir zoom en doble toque */
        }

        body {
            background-color: #1a1a1a;
            color: #f0f0f0;
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding: 10px;
            position: relative;
            overflow: hidden;
        }

        h1 {
            text-align: center;
            color: #fff;
            margin: 5px 0;
            font-size: clamp(18px, 4vw, 28px);
        }

        #status {
            text-align: center;
            color: #fff;
            margin: 5px 0;
            font-size: clamp(12px, 3vw, 18px);
            padding: 0 10px;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex: 1;
        }

        #canvasWrapper {
            position: relative;
            display: inline-block;
        }

        #livesDisplay {
            position: absolute;
            top: -35px;
            left: 10px;
            color: white;
            font-family: 'Arial', sans-serif;
            font-size: clamp(16px, 4vw, 24px);
            font-weight: bold;
            z-index: 10;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        }

        #controls {
            position: fixed;
            bottom: clamp(10px, 2vh, 20px);
            left: clamp(10px, 2vw, 20px);
            z-index: 20;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: clamp(8px, 2vw, 15px);
            touch-action: none;
        }

        #bombButton {
            position: fixed;
            bottom: clamp(10px, 2vh, 20px);
            right: clamp(10px, 2vw, 20px);
            width: clamp(60px, 15vw, 100px);
            height: clamp(60px, 15vw, 100px);
            z-index: 20;
            background-image: url('assets/BombaCorazon.png');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            background-color: transparent;
            border: none;
            touch-action: none;
        }

        .control-btn {
            background-color: rgba(255, 255, 255, 0.3);
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            color: white;
            font-size: clamp(20px, 5vw, 36px);
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            width: clamp(50px, 12vw, 70px);
            height: clamp(50px, 12vw, 70px);
            touch-action: none;
        }

        #btn-up { grid-column: 2; grid-row: 1; }
        #btn-left { grid-column: 1; grid-row: 2; }
        #btn-down { grid-column: 2; grid-row: 2; }
        #btn-right { grid-column: 3; grid-row: 2; }

        canvas {
            background-color: #4a5d23;
            border: clamp(2px, 0.5vw, 4px) solid #333;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
        }

        /* Media queries para diferentes orientaciones */
        @media (orientation: portrait) {
            #livesDisplay {
                top: -30px;
                left: 10px;
                font-size: clamp(14px, 3.5vw, 20px);
            }

            #controls {
                bottom: clamp(8px, 1.5vh, 15px);
                left: clamp(8px, 1.5vw, 15px);
            }

            #bombButton {
                bottom: clamp(8px, 1.5vh, 15px);
                right: clamp(8px, 1.5vw, 15px);
            }
        }

        @media (orientation: landscape) and (max-height: 500px) {
            h1 {
                display: none;
            }

            #status {
                font-size: clamp(10px, 2vw, 14px);
                margin: 2px 0;
            }

            #livesDisplay {
                top: -25px;
                left: 10px;
                font-size: clamp(12px, 3vw, 18px);
            }

            #controls {
                bottom: clamp(5px, 1vh, 10px);
                left: clamp(5px, 1vw, 10px);
                gap: clamp(5px, 1vw, 10px);
            }

            #bombButton {
                bottom: clamp(5px, 1vh, 10px);
                right: clamp(5px, 1vw, 10px);
                width: clamp(50px, 12vw, 80px);
                height: clamp(50px, 12vw, 80px);
            }

            .control-btn {
                width: clamp(40px, 10vw, 60px);
                height: clamp(40px, 10vw, 60px);
                font-size: clamp(18px, 4vw, 28px);
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 5px;
            }

            #livesDisplay {
                top: -25px;
                left: 10px;
                font-size: clamp(12px, 3vw, 16px);
            }

            body > p {
                display: none; /* Ocultar instrucciones en mÃ³viles pequeÃ±os */
            }
        }

        @media (max-width: 768px) {
            body > p {
                font-size: clamp(10px, 2vw, 12px);
                margin: 2px 0;
            }
        }

        #restartButton {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            background-color: #ff4444;
            color: white;
            border: 3px solid white;
            border-radius: 15px;
            padding: clamp(15px, 4vw, 25px) clamp(30px, 8vw, 50px);
            font-size: clamp(18px, 4vw, 28px);
            font-weight: bold;
            cursor: pointer;
            display: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            touch-action: manipulation;
            user-select: none;
        }

        #restartButton:hover {
            background-color: #ff6666;
        }

        #restartButton:active {
            background-color: #cc0000;
            transform: translate(-50%, -50%) scale(0.95);
        }

        #restartButton.show {
            display: block;
        }

        @media (orientation: landscape) {
            #restartButton {
                padding: clamp(10px, 2vh, 15px) clamp(20px, 5vw, 35px);
                font-size: clamp(16px, 3vw, 22px);
            }
        }
    </style>
</head>
<body>
    <h1>Baby Bomber</h1>
    <div id="gameContainer">
        <div id="canvasWrapper">
            <div id="livesDisplay">Vidas: 3</div>
            <canvas id="gameCanvas"></canvas>
        </div>
        <div id="controls">
            <div id="btn-up" class="control-btn">â–²</div>
            <div id="btn-left" class="control-btn">â—€</div>
            <div id="btn-down" class="control-btn">â–¼</div>
            <div id="btn-right" class="control-btn">â–¶</div>
        </div>
        <div id="bombButton"></div>
    </div>
    <h2 id="status">ðŸŽ¯ Objetivo: Â¡Encuentra la pista escondida!</h2>
    <p>Usa WASD o Flechas para moverte.</p>
    <button id="restartButton">ðŸ”„ Reiniciar Juego</button>

    <script>
        // --- 1. CONFIGURACIÃ“N DEL JUEGO ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const statusEl = document.getElementById('status');
        const livesDisplayEl = document.getElementById('livesDisplay');
        const gameContainer = document.getElementById('gameContainer');
        const restartButton = document.getElementById('restartButton');

        const TILE_SIZE = 40; // TamaÃ±o base de cada celda (pÃ­xeles)
        const ROWS = 13;      // 13 filas
        const COLS = 17;      // 17 columnas

        // TamaÃ±os internos del canvas (resoluciÃ³n lÃ³gica)
        const LOGICAL_WIDTH = COLS * TILE_SIZE;
        const LOGICAL_HEIGHT = ROWS * TILE_SIZE;

        // FunciÃ³n para calcular y ajustar el tamaÃ±o del canvas
        function resizeCanvas() {
            // Obtener el espacio disponible
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            
            // Calcular mÃ¡rgenes necesarios
            const isLandscape = vw > vh;
            
            if (isLandscape) {
                // En landscape, usar mÃ¡s espacio disponible
                // Los controles son mÃ¡s pequeÃ±os y el texto casi no existe
                const controlHeight = 100; // MÃ¡s pequeÃ±o
                const controlWidth = 100; // MÃ¡s pequeÃ±o
                const textHeight = 40; // Muy pequeÃ±o
                
                // Calcular espacio disponible (mÃ¡s agresivo en landscape)
                const availableWidth = vw - controlWidth - 10; // Margen mÃ­nimo
                const availableHeight = vh - textHeight - controlHeight - 10; // Margen mÃ­nimo
                
                // Calcular la escala basada en el espacio disponible
                const scaleX = availableWidth / LOGICAL_WIDTH;
                const scaleY = availableHeight / LOGICAL_HEIGHT;
                // En landscape, permitir escalar mÃ¡s grande si es necesario (hasta 1.2x)
                const scale = Math.min(scaleX, scaleY, 1.2);
                
                // Aplicar el tamaÃ±o visual al canvas
                canvas.style.width = (LOGICAL_WIDTH * scale) + 'px';
                canvas.style.height = (LOGICAL_HEIGHT * scale) + 'px';
            } else {
                // Portrait: usar mÃ¡rgenes mÃ¡s conservadores
                const controlHeight = 150;
                const controlWidth = 150;
                const textHeight = 120;
                
                // Calcular espacio disponible
                const availableWidth = vw - controlWidth - 20;
                const availableHeight = vh - textHeight - controlHeight - 20;
                
                // Calcular la escala basada en el espacio disponible
                const scaleX = availableWidth / LOGICAL_WIDTH;
                const scaleY = availableHeight / LOGICAL_HEIGHT;
                const scale = Math.min(scaleX, scaleY, 1);
                
                // Aplicar el tamaÃ±o visual al canvas
                canvas.style.width = (LOGICAL_WIDTH * scale) + 'px';
                canvas.style.height = (LOGICAL_HEIGHT * scale) + 'px';
            }
            
            // Mantener la resoluciÃ³n interna del canvas
            canvas.width = LOGICAL_WIDTH;
            canvas.height = LOGICAL_HEIGHT;
            
            // Ajustar el contexto para escalar correctamente
            ctx.setTransform(1, 0, 0, 1, 0, 0);
        }

        // Inicializar tamaÃ±o del canvas
        resizeCanvas();
        
        // Recalcular cuando cambia el tamaÃ±o de la ventana o la orientaciÃ³n
        // El gameLoop ya redibuja continuamente, asÃ­ que no necesitamos redibujar manualmente
        window.addEventListener('resize', resizeCanvas);
        
        window.addEventListener('orientationchange', () => {
            setTimeout(resizeCanvas, 100); // PequeÃ±o delay para que el navegador actualice las dimensiones
        });

        // DefiniciÃ³n del mapa
        const MAP_KEY = {
            EMPTY: 0,
            SOLID: 1,
            DESTRUCTIBLE: 2,
            CLUE_HIDDEN: 3,
            CLUE_REVEALED: 4 // The object on the ground
        };

        // --- CONFIGURACIONES DEL JUEGO (Ajusta estos valores aquÃ­) ---
        const GAME_CONFIG = {
            // Jugador
            playerSpeed: 4,                    // Velocidad de movimiento del jugador
            playerLives: 3,                    // NÃºmero de vidas iniciales
            playerSizeFactor: 0.8,             // TamaÃ±o del jugador relativo a TILE_SIZE (0.6 = 60%)
            playerSpriteScale: 1.5,            // Escala visual del sprite del jugador (1.5 = 50% mÃ¡s grande)
            playerInvincibilityTime: 120,      // Tiempo de invencibilidad despuÃ©s de ser golpeado (frames)
            
            // Bombas
            bombTimer: 90,                    // Tiempo antes de que explote la bomba (frames, ~3 segundos a 60fps)
            bombRange: 2,                      // Rango de la explosiÃ³n (nÃºmero de tiles en cada direcciÃ³n)
            
            // Explosiones
            explosionTimer: 20,                // DuraciÃ³n de la animaciÃ³n de explosiÃ³n (frames)
            
            // Pistas
            totalFakeClues: 10,                // NÃºmero de pistas falsas en el mapa
            fakeClueMessageTimer: 100,       // Tiempo que se muestra el mensaje de pista falsa (frames)
            
            // GeneraciÃ³n del mapa
            blockDestructibleProbability: 0.1  // Probabilidad de que una celda NO tenga bloque (0.1 = 90% tiene bloque)
        };

        let map = [];
        let bombs = [];
        let explosions = [];
        let clues = []; // Holds all clue objects {r, c, type, color, revealed}
        let fakeClueMessage = { timer: 0, color: null };
        let gameWon = false;
        let gameOver = false;

        // --- RUTAS DE ASSETS (Configura tus imÃ¡genes aquÃ­) ---
        const ASSET_PATHS = {
            blockDestructible: 'assets/Nube3.png',  // Bloque destructible (ladrillo)
            blockSolid: 'assets/Mamadera.png',          // Bloque sÃ³lido (pared)
            background: 'assets/Cielo.png',                          // Fondo del mapa (ej: 'assets/grass.png')
            player: 'assets/Bebe.png',                               // BebÃ©/jugador (ej: 'assets/baby.png')
            bomb: 'assets/BombaCorazon.png',                                // Bomba (ej: 'assets/bomb.png')
            explosion: 'assets/Fuego.png',                          // Fuego/explosiÃ³n (ej: 'assets/fire.png')
            clue: 'assets/Panal.png'                                 // Pista (ej: 'assets/clue.png')
        };

        // --- Assets (Sprites) ---
        const assets = {
            blockDestructible: null,  // Imagen para bloques destructibles
            blockSolid: null,         // Imagen para bloques sÃ³lidos (opcional)
            background: null,         // Imagen para el fondo del mapa (opcional)
            player: null,             // Imagen para el bebÃ©/jugador (opcional)
            bomb: null,               // Imagen para las bombas (opcional)
            explosion: null,          // Imagen para las explosiones/fuego (opcional)
            clue: null,               // Imagen para las pistas (opcional)
            loaded: false
        };

        // FunciÃ³n para cargar imÃ¡genes
        function loadAssets() {
            return new Promise((resolve) => {
                let loadedCount = 0;
                let totalAssets = 0;

                function checkLoaded() {
                    loadedCount++;
                    if (loadedCount >= totalAssets) {
                        assets.loaded = true;
                        resolve();
                    }
                }

                // Cargar sprite de bloque destructible
                if (ASSET_PATHS.blockDestructible) {
                    totalAssets++;
                    assets.blockDestructible = new Image();
                    assets.blockDestructible.onload = checkLoaded;
                    assets.blockDestructible.onerror = () => {
                        console.warn('No se pudo cargar el asset de bloque destructible. Usando dibujo por defecto.');
                        checkLoaded();
                    };
                    assets.blockDestructible.src = ASSET_PATHS.blockDestructible;
                } else {
                    assets.blockDestructible = null;
                }

                // Cargar sprite de bloque sÃ³lido (opcional)
                if (ASSET_PATHS.blockSolid) {
                    totalAssets++;
                    assets.blockSolid = new Image();
                    assets.blockSolid.onload = checkLoaded;
                    assets.blockSolid.onerror = () => {
                        console.warn('No se pudo cargar el asset de bloque sÃ³lido. Usando dibujo por defecto.');
                        checkLoaded();
                    };
                    assets.blockSolid.src = ASSET_PATHS.blockSolid;
                } else {
                    assets.blockSolid = null;
                }

                // Cargar sprite de fondo (opcional)
                if (ASSET_PATHS.background) {
                    totalAssets++;
                    assets.background = new Image();
                    assets.background.onload = checkLoaded;
                    assets.background.onerror = () => {
                        console.warn('No se pudo cargar el asset de fondo. Usando color por defecto.');
                        checkLoaded();
                    };
                    assets.background.src = ASSET_PATHS.background;
                } else {
                    assets.background = null;
                }

                // Cargar sprite del jugador/bebÃ© (opcional)
                if (ASSET_PATHS.player) {
                    totalAssets++;
                    assets.player = new Image();
                    assets.player.onload = checkLoaded;
                    assets.player.onerror = () => {
                        console.warn('No se pudo cargar el asset del jugador. Usando dibujo por defecto.');
                        checkLoaded();
                    };
                    assets.player.src = ASSET_PATHS.player;
                } else {
                    assets.player = null;
                }

                // Cargar sprite de bomba (opcional)
                if (ASSET_PATHS.bomb) {
                    totalAssets++;
                    assets.bomb = new Image();
                    assets.bomb.onload = checkLoaded;
                    assets.bomb.onerror = () => {
                        console.warn('No se pudo cargar el asset de bomba. Usando dibujo por defecto.');
                        checkLoaded();
                    };
                    assets.bomb.src = ASSET_PATHS.bomb;
                } else {
                    assets.bomb = null;
                }

                // Cargar sprite de explosiÃ³n/fuego (opcional)
                if (ASSET_PATHS.explosion) {
                    totalAssets++;
                    assets.explosion = new Image();
                    assets.explosion.onload = checkLoaded;
                    assets.explosion.onerror = () => {
                        console.warn('No se pudo cargar el asset de explosiÃ³n. Usando dibujo por defecto.');
                        checkLoaded();
                    };
                    assets.explosion.src = ASSET_PATHS.explosion;
                } else {
                    assets.explosion = null;
                }

                // Cargar sprite de pista (opcional)
                if (ASSET_PATHS.clue) {
                    totalAssets++;
                    assets.clue = new Image();
                    assets.clue.onload = checkLoaded;
                    assets.clue.onerror = () => {
                        console.warn('No se pudo cargar el asset de pista. Usando dibujo por defecto.');
                        checkLoaded();
                    };
                    assets.clue.src = ASSET_PATHS.clue;
                } else {
                    assets.clue = null;
                }

                // Si no hay assets para cargar, resolver inmediatamente
                if (totalAssets === 0) {
                    resolve();
                }
            });
        }

        // --- 2. EL JUGADOR (BEBÃ‰) ---
        let player = {
            x: TILE_SIZE * 1.5,
            y: TILE_SIZE * 1.5,
            initialX: TILE_SIZE * 1.5,
            initialY: TILE_SIZE * 1.5,
            size: TILE_SIZE * GAME_CONFIG.playerSizeFactor,
            speed: GAME_CONFIG.playerSpeed,
            color: '#FFDAB9',
            lives: GAME_CONFIG.playerLives,
            invincible: false,
            invincibleTimer: 0
        };

        // --- 3. GENERACIÃ“N DEL MAPA ---
        function generateMap() {
            clues = []; // Reset clues
            let destructibleBlocks = [];
            for (let r = 0; r < ROWS; r++) {
                map[r] = [];
                for (let c = 0; c < COLS; c++) {
                    if (r === 0 || r === ROWS - 1 || c === 0 || c === COLS - 1 || (r % 2 === 0 && c % 2 === 0)) {
                        map[r][c] = MAP_KEY.SOLID; // Paredes sÃ³lidas
                    } else {
                        // Evitar poner bloques donde empieza el jugador
                        if ((r === 1 && c === 1) || (r === 1 && c === 2) || (r === 2 && c === 1)) {
                             map[r][c] = MAP_KEY.EMPTY;
                        }
                        // Llenar el resto con bloques destruibles
                        else if (Math.random() > GAME_CONFIG.blockDestructibleProbability) {
                            map[r][c] = MAP_KEY.DESTRUCTIBLE;
                            destructibleBlocks.push({r, c});
                        } else {
                            map[r][c] = MAP_KEY.EMPTY;
                        }
                    }
                }
            }
            
            // --- Place Clues ---
            // Shuffle destructible blocks for random placement
            for (let i = destructibleBlocks.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [destructibleBlocks[i], destructibleBlocks[j]] = [destructibleBlocks[j], destructibleBlocks[i]];
            }

            // Place the real clue
            if (destructibleBlocks.length > 0) {
                const pos = destructibleBlocks.pop();
                map[pos.r][pos.c] = MAP_KEY.CLUE_HIDDEN;
                clues.push({ r: pos.r, c: pos.c, type: 'real', color: '#ADD8E6', revealed: false }); // Light Blue
            }

            // Place fake clues
            const fakeColors = ['#FFC0CB', '#FFB6C1', '#F08080', '#FA8072', '#72CAFA', '#08A8FF', '#056599']; // Pinks/Reds
            for (let i = 0; i < GAME_CONFIG.totalFakeClues && destructibleBlocks.length > 0; i++) {
                const pos = destructibleBlocks.pop();
                map[pos.r][pos.c] = MAP_KEY.CLUE_HIDDEN;
                clues.push({ r: pos.r, c: pos.c, type: 'fake', color: fakeColors[i % fakeColors.length], revealed: false });
            }
        }

        // --- 4. CONTROLES ---
        let keys = {};
        
        document.addEventListener('keydown', e => keys[e.code] = true);
        document.addEventListener('keyup', e => keys[e.code] = false);

        document.addEventListener('keydown', e => {
            if (e.code === 'Space' && !gameWon && !gameOver) {
                placeBomb();
            }
        });

        // --- Mobile Controls ---
        function setupMobileControls() {
            const keyMap = {
                'btn-up': 'KeyW',
                'btn-down': 'KeyS',
                'btn-left': 'KeyA',
                'btn-right': 'KeyD'
            };

            for (const btnId in keyMap) {
                const btn = document.getElementById(btnId);
                const key = keyMap[btnId];
                btn.addEventListener('touchstart', (e) => { e.preventDefault(); keys[key] = true; }, { passive: false });
                btn.addEventListener('touchend', (e) => { e.preventDefault(); keys[key] = false; }, { passive: false });
                btn.addEventListener('mousedown', (e) => { e.preventDefault(); keys[key] = true; });
                btn.addEventListener('mouseup', (e) => { e.preventDefault(); keys[key] = false; });
                btn.addEventListener('mouseleave', (e) => { keys[key] = false; }); // Stop moving if finger slides off
            }

            const bombBtn = document.getElementById('bombButton');
            bombBtn.addEventListener('touchstart', (e) => { e.preventDefault(); placeBomb(); }, { passive: false });
            bombBtn.addEventListener('mousedown', (e) => { e.preventDefault(); placeBomb(); });
        }

        // --- 5. LÃ“GICA DEL JUEGO (UPDATE) ---
        // Sistema de delta time para normalizar velocidad en diferentes tasas de refresco
        let lastTime = performance.now();
        const TARGET_FPS = 60;
        const FRAME_TIME = 1000 / TARGET_FPS; // Tiempo por frame a 60fps en ms
        
        function update() {
            if (gameWon || gameOver) return;

            // Calcular delta time
            const currentTime = performance.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            // Factor de normalizaciÃ³n basado en 60fps
            // Si el delta time es muy pequeÃ±o (alta tasa de refresco), el factor serÃ¡ > 1
            // Si el delta time es muy grande (baja tasa de refresco), el factor serÃ¡ < 1
            const deltaFactor = deltaTime / FRAME_TIME;
            
            // Limitar el factor para evitar saltos extremos
            const normalizedDelta = Math.min(Math.max(deltaFactor, 0.1), 2.0);

            // If a fake clue message is active, only update its timer and pause everything else.
            if (fakeClueMessage.timer > 0) {
                fakeClueMessage.timer -= normalizedDelta;
                return;
            }

            movePlayer(normalizedDelta);
            updateBombs(normalizedDelta);
            updateExplosions(normalizedDelta);
            updatePlayer(normalizedDelta);
            checkCluePickup();
        }

        function checkCluePickup() {
            const playerCol = Math.floor(player.x / TILE_SIZE);
            const playerRow = Math.floor(player.y / TILE_SIZE);

            if (map[playerRow][playerCol] !== MAP_KEY.CLUE_REVEALED) return;

            const pickedClueIndex = clues.findIndex(c => c.revealed && c.r === playerRow && c.c === playerCol);
            if (pickedClueIndex === -1) return;

            const pickedClue = clues[pickedClueIndex];

            if (pickedClue.type === 'real') {
                gameWon = true;
            } else {
                // It's a fake clue
                fakeClueMessage.timer = GAME_CONFIG.fakeClueMessageTimer;
                fakeClueMessage.color = pickedClue.color;
                map[playerRow][playerCol] = MAP_KEY.EMPTY; // Remove from map
                clues.splice(pickedClueIndex, 1); // Remove from clues array
            }
        }

        function updatePlayer(delta) {
            if (player.invincible) {
                player.invincibleTimer -= delta;
                if (player.invincibleTimer <= 0) {
                    player.invincible = false;
                    player.color = '#FFDAB9'; // Restore original color
                } else {
                    // Blink effect
                    player.color = (player.invincibleTimer % 20 < 10) ? 'white' : '#FFDAB9';
                }
            }
        }

        function movePlayer(delta) {
            let dx = 0;
            let dy = 0;

            if (keys['KeyW'] || keys['ArrowUp']) dy = -player.speed;
            if (keys['KeyS'] || keys['ArrowDown']) dy = player.speed;
            if (keys['KeyA'] || keys['ArrowLeft']) dx = -player.speed;
            if (keys['KeyD'] || keys['ArrowRight']) dx = player.speed;

            // Aplicar delta time a la velocidad
            dx *= delta;
            dy *= delta;

            // DetecciÃ³n de colisiones simple
            // Revisa la prÃ³xima posiciÃ³n X
            if (dx !== 0 && !isSolid(player.x + dx, player.y)) {
                player.x += dx;
            }
            // Revisa la prÃ³xima posiciÃ³n Y
            if (dy !== 0 && !isSolid(player.x, player.y + dy)) {
                player.y += dy;
            }
        }
        
        function getTileAt(x, y) {
            const r = Math.floor(y / TILE_SIZE);
            const c = Math.floor(x / TILE_SIZE);
            if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return MAP_KEY.SOLID;
            return map[r][c];
        }

        function isSolid(x, y) {
            // Revisa las 4 esquinas del "bebÃ©"
            const radius = player.size / 2;
            const tile1 = getTileAt(x - radius, y - radius); // Arriba-Izquierda
            const tile2 = getTileAt(x + radius, y - radius); // Arriba-Derecha
            const tile3 = getTileAt(x - radius, y + radius); // Abajo-Izquierda
            const tile4 = getTileAt(x + radius, y + radius); // Abajo-Derecha
            
            const solidTypes = [MAP_KEY.SOLID, MAP_KEY.DESTRUCTIBLE, MAP_KEY.CLUE_HIDDEN];
            
            return solidTypes.includes(tile1) || solidTypes.includes(tile2) || solidTypes.includes(tile3) || solidTypes.includes(tile4);
        }

        function placeBomb() {
            // Centrar la bomba en la celda actual
            const r = Math.floor(player.y / TILE_SIZE);
            const c = Math.floor(player.x / TILE_SIZE);

            // Evitar poner dos bombas en la misma celda
            if (bombs.some(b => b.r === r && b.c === c)) return;

            bombs.push({
                r: r,
                c: c,
                timer: GAME_CONFIG.bombTimer,
                range: GAME_CONFIG.bombRange
            });
        }

        function updateBombs(delta) {
            for (let i = bombs.length - 1; i >= 0; i--) {
                bombs[i].timer -= delta;
                if (bombs[i].timer <= 0) {
                    explode(bombs[i]);
                    bombs.splice(i, 1);
                }
            }
        }
        
        function explode(bomb) {
            const dirs = [[0, 0], [0, 1], [0, -1], [1, 0], [-1, 0]]; // Centro, Abajo, Arriba, Derecha, Izquierda
            
            for (const dir of dirs) {
                for (let i = 0; i <= bomb.range; i++) {
                    const r = bomb.r + dir[0] * i;
                    const c = bomb.c + dir[1] * i;

                    if (r < 0 || r >= ROWS || c < 0 || c >= COLS) break;

                    const tile = map[r][c];
                    
                    // AÃ±adir efecto de explosiÃ³n
                    explosions.push({ r, c, timer: GAME_CONFIG.explosionTimer });

                    if (tile === MAP_KEY.SOLID) {
                        break; // La explosiÃ³n se detiene en pared sÃ³lida
                    }
                    
                    if (tile === MAP_KEY.DESTRUCTIBLE || tile === MAP_KEY.CLUE_HIDDEN) {
                        // Check if a clue is hidden here
                        const clue = clues.find(clue => clue.r === r && clue.c === c);
                        if (clue) {
                            clue.revealed = true;
                            map[r][c] = MAP_KEY.CLUE_REVEALED; // Reveal the clue object
                            statusEl.textContent = "Â¡Encontraste algo! Â¡Ve a recogerlo!";
                        } else {
                            map[r][c] = MAP_KEY.EMPTY; // Just destroy the block
                        }
                        break; // The explosion stops after destroying a block or revealing a clue
                    }
                }
            }
        }
        
        function updateExplosions(delta) {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const exp = explosions[i];
                exp.timer -= delta;

                // Comprobar colisiÃ³n con el jugador
                const playerCol = Math.floor(player.x / TILE_SIZE);
                const playerRow = Math.floor(player.y / TILE_SIZE);
                if (exp.r === playerRow && exp.c === playerCol && !player.invincible) {
                    playerHit();
                }

                if (exp.timer <= 0) {
                    explosions.splice(i, 1);
                }
            }
        }

        function playerHit() {
            if (player.invincible) return;

            player.lives--;
            if (player.lives <= 0) {
                gameOver = true;
                statusEl.textContent = "GAME OVER";
                // Mostrar botÃ³n de reinicio
                restartButton.classList.add('show');
            } else {
                // Respawn y dar invencibilidad temporal
                player.x = player.initialX;
                player.y = player.initialY;
                player.invincible = true;
                player.invincibleTimer = GAME_CONFIG.playerInvincibilityTime;
            }
        }

        function restartGame() {
            // Ocultar botÃ³n de reinicio
            restartButton.classList.remove('show');
            
            // Reinicializar delta time para evitar saltos
            lastTime = performance.now();
            
            player.lives = GAME_CONFIG.playerLives;
            player.x = player.initialX;
            player.y = player.initialY;
            player.invincible = false;
            player.invincibleTimer = 0;
            
            bombs = [];
            explosions = [];
            clues = []; // This will be repopulated by generateMap
            fakeClueMessage = { timer: 0, color: null };
            gameWon = false;
            gameOver = false;
            
            statusEl.textContent = "ðŸŽ¯ Objetivo: Â¡Encuentra la pista escondida!";
            generateMap();
        }

        // Agregar event listener al botÃ³n de reinicio
        restartButton.addEventListener('click', restartGame);
        restartButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            restartGame();
        }, { passive: false });

        // --- 6. RENDERIZADO (DRAW) ---
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (gameWon) {
                drawWinScreen();
            } else if (fakeClueMessage.timer > 0) {
                drawFakeClueScreen();
            } else {
                drawMap();
                drawBombs();
                drawExplosions();
                drawPlayer();
                drawUI();
            }
        }

        function drawFakeClueScreen() {
            // Draw a full-screen rectangle with the clue's color
            ctx.fillStyle = fakeClueMessage.color;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw the text
            ctx.fillStyle = 'white';
            ctx.font = 'bold 40px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("Pista falsa, siga jugando", canvas.width / 2, canvas.height / 2);
        }

        function drawWinScreen() {
            // A big light blue square
            ctx.fillStyle = 'lightblue';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Text
            ctx.fillStyle = 'white';
            ctx.font = 'bold 60px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText("Â¡ES UN NIÃ‘O!", canvas.width / 2, canvas.height / 2);
            
            statusEl.textContent = "ðŸŽ‰ Â¡FELICIDADES! ðŸŽ‰";
        }

        function drawUI() {
            // Actualizar el texto de vidas en el elemento HTML (por encima del canvas)
            livesDisplayEl.textContent = `Vidas: ${player.lives}`;
        }

        function drawBackground() {
            // Dibujar el fondo del mapa (imagen o color sÃ³lido)
            if (assets.background && assets.background.complete && assets.background.naturalWidth > 0) {
                // Si hay imagen de fondo, dibujarla para todo el mapa
                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const x = c * TILE_SIZE;
                        const y = r * TILE_SIZE;
                        ctx.drawImage(assets.background, x, y, TILE_SIZE, TILE_SIZE);
                    }
                }
            } else {
                // Si no hay imagen, usar el color de fondo (verde oscuro tipo bomberman)
                ctx.fillStyle = '#4a5d23';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        function drawMap() {
            // Primero dibujar el fondo
            drawBackground();

            // Luego dibujar los elementos del mapa
            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const x = c * TILE_SIZE;
                    const y = r * TILE_SIZE;
                    
                    switch(map[r][c]) {
                        case MAP_KEY.SOLID:
                            // Usar imagen si estÃ¡ cargada, sino usar el rectÃ¡ngulo por defecto
                            if (assets.blockSolid && assets.blockSolid.complete && assets.blockSolid.naturalWidth > 0) {
                                ctx.drawImage(assets.blockSolid, x, y, TILE_SIZE, TILE_SIZE);
                            } else {
                                ctx.fillStyle = '#555'; // Gris oscuro
                                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                            }
                            break;
                        case MAP_KEY.DESTRUCTIBLE:
                        case MAP_KEY.CLUE_HIDDEN: // Se ve igual que un bloque normal
                            // Usar imagen si estÃ¡ cargada, sino usar el rectÃ¡ngulo por defecto
                            if (assets.blockDestructible && assets.blockDestructible.complete && assets.blockDestructible.naturalWidth > 0) {
                                ctx.drawImage(assets.blockDestructible, x, y, TILE_SIZE, TILE_SIZE);
                            } else {
                                ctx.fillStyle = '#8B4513'; // MarrÃ³n (ladrillo)
                                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                            }
                            break;
                        case MAP_KEY.CLUE_REVEALED:
                            const clue = clues.find(clue => clue.r === r && clue.c === c);
                            if (clue) {
                                // Usar imagen si estÃ¡ cargada, sino usar el cÃ­rculo por defecto
                                if (assets.clue && assets.clue.complete && assets.clue.naturalWidth > 0) {
                                    ctx.drawImage(assets.clue, x, y, TILE_SIZE, TILE_SIZE);
                                } else {
                                    ctx.fillStyle = clue.color;
                                    ctx.beginPath();
                                    ctx.arc(x + TILE_SIZE / 2, y + TILE_SIZE / 2, TILE_SIZE / 4, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                            }
                            break;
                        case MAP_KEY.EMPTY:
                            // El fondo ya se dibujÃ³ en drawBackground()
                            break;
                    }
                }
            }
        }
        
        function drawPlayer() {
            // Usar imagen si estÃ¡ cargada, sino usar el cÃ­rculo por defecto
            if (assets.player && assets.player.complete && assets.player.naturalWidth > 0) {
                // Hacer el sprite mÃ¡s grande (multiplicador de escala visual)
                const size = player.size * GAME_CONFIG.playerSpriteScale;
                ctx.drawImage(assets.player, player.x - size / 2, player.y - size / 2, size, size);
            } else {
                ctx.fillStyle = player.color;
                ctx.beginPath();
                ctx.arc(player.x, player.y, player.size / 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawBombs() {
            for (const bomb of bombs) {
                const x = bomb.c * TILE_SIZE + TILE_SIZE / 2;
                const y = bomb.r * TILE_SIZE + TILE_SIZE / 2;
                
                // Usar imagen si estÃ¡ cargada, sino usar el dibujo por defecto
                if (assets.bomb && assets.bomb.complete && assets.bomb.naturalWidth > 0) {
                    // Efecto de parpadeo
                    const scale = (bomb.timer % 10 < 5) ? 0.7 : 0.8;
                    const size = TILE_SIZE * scale;
                    ctx.drawImage(assets.bomb, x - size / 2, y - size / 2, size, size);
                } else {
                    // Efecto de parpadeo
                    const scale = (bomb.timer % 10 < 5) ? 0.7 : 0.8;
                    
                    ctx.fillStyle = '#222'; // Bomba negra
                    ctx.beginPath();
                    ctx.arc(x, y, (TILE_SIZE / 2) * scale, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.fillStyle = 'white'; // Mecha
                    ctx.fillRect(x - 2, y - (TILE_SIZE / 2) * scale - 5, 4, 5);
                }
            }
        }
        
        function drawExplosions() {
            for (const exp of explosions) {
                const x = exp.c * TILE_SIZE;
                const y = exp.r * TILE_SIZE;
                
                // Usar imagen si estÃ¡ cargada, sino usar el rectÃ¡ngulo por defecto
                if (assets.explosion && assets.explosion.complete && assets.explosion.naturalWidth > 0) {
                    // La opacidad disminuye con el tiempo
                    ctx.globalAlpha = exp.timer / GAME_CONFIG.explosionTimer;
                    ctx.drawImage(assets.explosion, x, y, TILE_SIZE, TILE_SIZE);
                    ctx.globalAlpha = 1.0; // Restaurar opacidad
                } else {
                    // La opacidad disminuye con el tiempo
                    ctx.fillStyle = `rgba(255, 165, 0, ${exp.timer / (GAME_CONFIG.explosionTimer / 2)})`; 
                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                }
            }
        }

        // --- 7. BUCLE PRINCIPAL DEL JUEGO ---
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }

        // Iniciar el juego
        async function initGame() {
            await loadAssets();
            generateMap();
            setupMobileControls();
            lastTime = performance.now(); // Inicializar lastTime antes de empezar el loop
            gameLoop();
        }

        initGame();
    </script>
</body>
</html>
